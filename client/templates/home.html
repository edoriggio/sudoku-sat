<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Sudoku Solver</title>

    <style>
        html, body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            width: 100%;
            height: 100%;
            color: transparent;
        }

        .sudoku-grid {
            border-collapse: collapse;
        }

        .sudoku-cell {
            height: 30px;
            width: 30px;
            border: 1px solid black;
            text-align: center;
            font-size: 18px;
        }

        .sudoku-cell:nth-child(1) {
            border-left: 3px solid black;
        }

        .sudoku-row:nth-child(1) {
            border-top: 3px solid black;
        }

        .sudoku-cell:nth-child(3n) {
            border-right: 3px solid black;
        }

        .sudoku-row:nth-child(3n) {
            border-bottom: 3px solid black;
        }

        #drop-zone {
            display: flex;
            margin: 0;
            justify-content: center;
            border: 3px dashed transparent;
            position: absolute;
            width: calc(100% - 8px);
            height: calc(100% - 8px);
        }

        #button-send {
            z-index: 1000;
            margin-top: 20px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <table class="sudoku-grid">
        {% for col in sol_matrix %}
            <tr class="sudoku-row">
                {% with loop_1=forloop.counter0 %}
                {% for el in col %}
                    <td id="{{ loop_1 }},{{ forloop.counter0 }}" class="sudoku-cell">{{ el }}</td>
                {% endfor %}
                {% endwith %}
            </tr>
        {% endfor %}
    </table>

    <button id="button-send" onclick="buttonCallback()">Solve</button>

    <div id="drop-zone" ondrop="dropHandler(event);" ondragover="dragOverHandler(event);" ondragleave="dragLeaveHandler()">
        <div id="drop-zone_inner"> </div>
    </div>

    {% csrf_token %}
    <script>
        let file = null
        const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value

        function buttonCallback() {
            let xhr = new XMLHttpRequest();
            xhr.open("POST", 'solve', true);
            xhr.setRequestHeader('X-CSRFToken', csrftoken);
            xhr.send(file);
            xhr.addEventListener("load", transferComplete);
        }

        function dropHandler(ev) {
            ev.preventDefault()

            if (ev.dataTransfer.items.length > 1) {
                alert('Only one file can be uploaded at a time.')

                document.getElementById('drop-zone').style.borderColor = "transparent"
            } else if (ev.dataTransfer.items[0].getAsFile().type !== 'text/plain') {
                alert('File must be TXT.')

                document.getElementById('drop-zone').style.borderColor = "transparent"
            } else {
                file = ev.dataTransfer.items[0].getAsFile()

                file.text().then((res) => {
                    let pos = []
                    let parsed_res = res.split("\n")
                    let cells = document.getElementsByClassName("sudoku-cell")

                    for (let cell in cells) {
                        cells[cell].innerHTML = " "
                    }

                    for (let element in parsed_res) {
                        let split = parsed_res[element].split(",")

                        let x = split[0]
                        let y = split[1]
                        let n = split[2]

                        pos.push([parseInt(x)-1,parseInt(y)-1, parseInt(n)])
                    }

                    for (let element in pos) {
                        document.getElementById(`${pos[element][0]},${pos[element][1]}`).innerHTML = pos[element][2]
                        document.getElementById(`${pos[element][0]},${pos[element][1]}`).style.backgroundColor = "lightgray"
                        document.getElementById(`${pos[element][0]},${pos[element][1]}`).style.color = 'black'
                    }
                })

                document.getElementById('drop-zone').style.borderColor = "transparent"
            }
        }

        function transferComplete() {
            let solution = JSON.parse(this.responseText)["sol_matrix"]

            for (let i = 0; i < solution.length; i++) {
                for (let j = 0; j < solution[i].length; j++) {
                    document.getElementById(`${i},${j}`).innerHTML = solution[i][j]
                }
            }

            animateNumbers()
        }

        function dragOverHandler(ev) {
            ev.preventDefault();

            document.getElementById('drop-zone').style.borderColor = "#0B6EFD"
        }

        function dragLeaveHandler() {
            document.getElementById('drop-zone').style.borderColor = "transparent"
        }

        function animateNumbers() {
            let cells = []

            for (let i = 0; i < 81; i++) {
                cells.push(i)
            }

            let currentIndex = cells.length;
            while (currentIndex !== 0) {
                let randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;

                [cells[currentIndex], cells[randomIndex]] = [cells[randomIndex], cells[currentIndex]];
            }

            let table_cells = document.getElementsByTagName('td')
            for (let i = 0; i < table_cells.length; i++) {
                setTimeout(() => { table_cells[cells[i]].style.color = 'black'}, 20 * i);
            }
        }


    </script>
</body>
</html>